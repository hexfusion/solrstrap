.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Vend::Payment::Merchantware 3"
.TH Vend::Payment::Merchantware 3 "2016-12-23" "perl v5.22.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Vend::Payment::Merchantware \- Interchange Merchant Warehouse Support
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    &charge=merchantware
\& 
\&        or
\& 
\&    [charge mode=merchantware param1=value1 param2=value2]
.Ve
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
.Vb 1
\& SOAP::Lite
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Vend::Payment::Merchantware module implements the \fImerchantware()\fR routine
for use with Interchange. It is compatible on a call level with the other
Interchange payment modules \*(-- in theory (and even usually in practice) you
could switch from a different payment module to Merchantware with a few
configuration file changes.
.PP
To enable this module, place this directive in \f(CW\*(C`interchange.cfg\*(C'\fR:
.PP
.Vb 1
\&    Require module Vend::Payment::Merchantware
.Ve
.PP
This \fImust\fR be in interchange.cfg or a file included from it.
.PP
Make sure CreditCardAuto is off (default in Interchange demos).
.PP
The mode can be named anything, but the \f(CW\*(C`gateway\*(C'\fR parameter must be set
to \f(CW\*(C`merchantware\*(C'\fR. To make it the default payment gateway for all credit
card transactions in a specific catalog, you can set in \f(CW\*(C`catalog.cfg\*(C'\fR:
.PP
.Vb 1
\&    Variable   MV_PAYMENT_MODE  merchantware
.Ve
.PP
It uses several of the standard settings from Interchange payment. Any time
we speak of a setting, it is obtained either first from the tag/call options,
then from an Interchange order Route named for the mode, then finally a
default global payment variable, For example, the \f(CW\*(C`id\*(C'\fR parameter would
be specified by:
.PP
.Vb 1
\&    [charge mode=merchantware id=YourMerchantwareID]
.Ve
.PP
or
.PP
.Vb 1
\&    Route merchantware id YourMerchantwareID
.Ve
.PP
or with only Merchantware as a payment provider
.PP
.Vb 1
\&    Variable MV_PAYMENT_ID      YourMerchantwareID
.Ve
.PP
The active settings are:
.IP "id" 4
.IX Item "id"
Your account \s-1ID,\s0 supplied by Merchant Warehouse when you sign up.
Global parameter is \s-1MV_PAYMENT_ID.\s0
.IP "secret" 4
.IX Item "secret"
Your account key (not password), provided by Merchant Warehouse when you
sign up. Global parameter is \s-1MV_PAYMENT_SECRET.\s0
.IP "partner" 4
.IX Item "partner"
Your account name, selected by you or provided by Merchant Warehouse
when you sign up. Global parameter is \s-1MV_PAYMENT_PARTNER.\s0
.IP "transaction" 4
.IX Item "transaction"
The type of transaction to be run. Valid values are:
.Sp
.Vb 11
\&    Interchange         Merchantware
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        auth            PreAuthorizationKeyed
\&        sale            SaleKeyed
\&        credit          Refund
\&        void            Void
\&        settle          PostAuthorization  (from previous auth transaction)
\&        repeat_sale     RepeatSale  (from previous sale or auth transaction)
\&        void_auth       VoidPreAuthorization
\&        settle_batch    SettleBatch
\&        level2_sale     Level2SaleKeyed
.Ve
.Sp
Default is \f(CW\*(C`sale\*(C'\fR.
.IP "check_sub" 4
.IX Item "check_sub"
Name of a Sub or GlobalSub to be called after the result hash has been
received. A reference to the modifiable result hash is passed into the
subroutine, and it should return true (in the Perl truth sense) if its
checks were successful, or false if not. The transaction type is passed
in as a second arg, if needed.
.Sp
This can come in handy since, strangely, MerchantWare has no option to
decline a charge when \s-1AVS\s0 or \s-1CSC\s0 data come back negative.
.Sp
If you want to fail based on a bad \s-1AVS\s0 check, make sure you're only
doing an auth \*(-- \fBnot a sale\fR, or your customers would get charged on
orders that fail the \s-1AVS\s0 check and never get logged in your system!
.Sp
Add the parameters like this:
.Sp
.Vb 1
\&    Route  merchantware  check_sub  mw_check
.Ve
.Sp
This is a matching sample subroutine you could put in interchange.cfg:
.Sp
.Vb 10
\&    GlobalSub <<EOR
\&    sub mw_check {
\&                my ($result, $transtype) = @_;
\&                my ($avs, $cvv) = @{$result}{qw( AvsResponse CvResponse )};
\&                return 1 unless $transtype eq \*(Aqauth\*(Aq;
\&#::logDebug("mw_check: transtype=$transtype; avs=$avs, cvv=$cvv");
\&                return 1 if $avs eq \*(AqX\*(Aq or $avs eq \*(AqY\*(Aq;   # address and zip match
\&                return 1 if $avs eq \*(AqA\*(Aq or $avs eq \*(AqZ\*(Aq or $avs eq \*(AqW\*(Aq;   # address or zip match
\&                return 1 if $avs eq \*(AqU\*(Aq or $avs eq \*(AqG\*(Aq;   # address info not available
\&                return 1 if $avs eq \*(AqR\*(Aq or $avs eq \*(AqS\*(Aq;   # system unavailable, not supported
\&                return 1 if $avs =~ /^[BDMP]$/;           # intl match on address or postal
\&                ## if we made it to this line, then the address is bad... (thus, we don\*(Aqt care about CVV if address is good)
\&                ## below, we can accept if CVV is good, even if address is bad.
\&                return 1 if $cvv =~ /^[MPSUX]$/;   # accept all CVV responses, except no\-match
\&                if ( !$cvv or $cvv eq \*(AqN\*(Aq ) {
\&                        $result\->{RESULT} = 99;
\&                        $result\->{ErrorMessage} = q{The card security code you entered does not match. Additional failed attempts may hold your available funds};
\&                }
\&                else {
\&                        $result\->{RESULT} = 112;
\&                        $result\->{ErrorMessage} = q{The billing address you entered does not match the cardholder\*(Aqs billing address};
\&                }
\&                $result\->{MStatus} = \*(Aqfailure\*(Aq;
\&                return 0;
\&    }
\&    EOR
.Ve
.Sp
That would work equally well as a Sub in catalog.cfg. It will succeed
if either the address or zip is 'Y', or if both are unknown. If it
fails, it sets the result code and error message in the result hash
using Merchantware's own (otherwise unused) 112 result code, meaning
\&\f(CW\*(C`Failed AVS check\*(C'\fR.
.Sp
Of course you can use this sub to do any other post-processing you
want as well.
.PP
The following should rarely be used, as the supplied defaults are
usually correct.
.IP "remap" 4
.IX Item "remap"
This remaps the form variable names to the ones needed by Merchantware. See
the \f(CW\*(C`Payment Settings\*(C'\fR heading in the Interchange documentation for use.
.IP "test" 4
.IX Item "test"
Set this to \f(CW\*(C`TRUE\*(C'\fR if you wish to operate in test mode.
.Sp
Examples:
.Sp
.Vb 5
\&    Route    merchantware  test  TRUE
\&        or
\&    Variable   MV_PAYMENT_TEST   TRUE
\&        or 
\&    [charge mode=merchantware test=TRUE]
.Ve
.SS "Troubleshooting"
.IX Subsection "Troubleshooting"
Try the instructions above, then enable test mode. A test order
should complete.
.PP
Then move to live mode and try a sale with the card number \f(CW\*(C`4111 1111
1111 1111\*(C'\fR and a valid future expiration date. The sale should be denied,
and the reason should be in [data session payment_error].
.PP
If it doesn't work:
.IP "\(bu" 4
Make sure you \*(L"Require\*(R"d the module in interchange.cfg:
.Sp
.Vb 1
\&    Require module Vend::Payment::Merchantware
.Ve
.IP "\(bu" 4
Check the error logs, both catalog and global.
.IP "\(bu" 4
Make sure you set your payment parameters properly.
.IP "\(bu" 4
Try an order, then put this code in a page:
.Sp
.Vb 8
\&    <XMP>
\&    [calc]
\&        my $string = $Tag\->uneval( { ref => $Session\->{payment_result} });
\&        $string =~ s/{/{\en/;
\&        $string =~ s/,/,\en/g;
\&        return $string;
\&    [/calc]
\&    </XMP>
.Ve
.Sp
That should show what happened.
.IP "\(bu" 4
If all else fails, consultants are available to help with
integration for a fee. You can find consultants by asking on the
\&\f(CW\*(C`interchange\-biz@icdevgroup.org\*(C'\fR mailing list.
.SH "TOKENS"
.IX Header "TOKENS"
MerchantWarehouse returns a token for each transaction. This is a
reference to the customer's credit card used in the original sale or
auth transaction, which you can use for future transactions against
that card.
.PP
For example, you can run a \f(CW\*(C`repeat_sale\*(C'\fR using the token and expiration
date.
.Sp
.RS 4
You can also send the street address and \s-1ZIP\s0 for a \f(CW\*(C`repeat_sale\*(C'\fR, so
MerchantWarehouse will run the \s-1AVS\s0 check. However, note that \s-1MW\s0 will not
decline a \f(CW\*(C`repeat_sale\*(C'\fR if the \s-1AVS\s0 doesn't match \*(-- this handling is
done via our check_sub. This is why the check_sub only fails on \s-1AVS\s0
mismatch for \f(CW\*(C`auth\*(C'\fR transactions. Thus, if you decide to fail a
\&\f(CW\*(C`repeat_sale\*(C'\fR based on \s-1AVS\s0 mismatch, you will need to modify the
\&\f(CW\*(C`check_sub\*(C'\fR to \f(CW\*(C`void\*(C'\fR the \f(CW\*(C`repeat_sale\*(C'\fR.
.RE
.PP
Tokens are valid for 18 months. However, each transaction returns a new
token of its own, so if you update your system to replace your original
token with the one returned, you can effectively have a valid token for
the life of the credit card (or until the expiration date is reached).
.SH "REFERENCE"
.IX Header "REFERENCE"
.SS "Transaction Types (not all supported or available)"
.IX Subsection "Transaction Types (not all supported or available)"
.Vb 12
\&        UNKNOWN 0       This value is reserved.
\&        SALE    1       A SALE charges an amount of money to a customer\*(Aqs credit card.
\&        REFUND  2       A REFUND credits an amount of money to a customer\*(Aqs credit card.
\&        VOID    3       A VOID removes a SALE, REFUND, FORCE, POSTAUTH, or ADJUST transaction from the current credit card processing batch.
\&        FORCE   4       A FORCE forces a charge on a customer\*(Aqs credit card. 
\&        AUTH    5       An AUTH reserves or holds an amount of money on a customer\*(Aqs credit card. 
\&        CAPTURE 6       A CAPTURE commits a single transaction as though it were batched. This feature is unsupported.
\&        ADJUST  7       An ADJUST is an adjustment on the amount of a prior sale or capture. Usually this is employed by businesses where tip\-adjust on credit transactions are allowed.
\&        REPEATSALE      8       A REPEATSALE is a repeated sale of a prior sale transaction. Most accounts and merchants do not use this transaction type.
\&        POSTAUTH        9       A POSTAUTH completes the transaction process for a prior Authorization and allows it to enter the batch.
\&        LEVELUPSALE     11      A LEVELUPSALE charges an amount of money to a customer\*(Aqs LevelUp account.
\&        LEVELUPCREDIT   12      A LEVELUPCREDIT credits an amount of money to a customer\*(Aqs LevelUp account.
.Ve
.SS "Response Values (Error Codes)"
.IX Subsection "Response Values (Error Codes)"
.Vb 10
\&        \-100    Transaction NOT Processed; Generic Host Error
\&        0       Approved
\&        1       User Authentication Failed
\&        2       Invalid Transaction
\&        3       Invalid Transaction Type
\&        4       Invalid Amount
\&        5       Invalid Merchant Information
\&        7       Field Format Error
\&        8       Not a Transaction Server
\&        9       Invalid Parameter Stream
\&        10      Too Many Line Items
\&        11      Client Timeout Waiting for Response
\&        12      Decline
\&        13      Referral
\&        14      Transaction Type Not Supported In This Version
\&        19      Original Transaction ID Not Found
\&        20      Customer Reference Number Not Found
\&        22      Invalid ABA Number
\&        23      Invalid Account Number
\&        24      Invalid Expiration Date
\&        25      Transaction Type Not Supported by Host
\&        26      Invalid Reference Number
\&        27      Invalid Receipt Information
\&        28      Invalid Check Holder Name
\&        29      Invalid Check Number
\&        30      Check DL Verification Requires DL State
\&        40      Transaction did not connect (to NCN because SecureNCIS is not running on the web server)
\&        50      Insufficient Funds Available
\&        99      General Error
\&        100     Invalid Transaction Returned from Host
\&        101     Timeout Value too Small or Invalid Time Out Value
\&        102     Processor Not Available
\&        103     Error Reading Response from Host
\&        104     Timeout waiting for Processor Response
\&        105     Credit Error
\&        106     Host Not Available
\&        107     Duplicate Suppression Timeout
\&        108     Void Error
\&        109     Timeout Waiting for Host Response
\&        110     Duplicate Transaction
\&        111     Capture Error
\&        112     Failed AVS Check
\&        113     Cannot Exceed Sales Cap
\&        1000    Generic Host Error
\&        1001    Invalid Login
\&        1002    Insufficient Privilege or Invalid Amount
\&        1003    Invalid Login Blocked
\&        1004    Invalid Login Deactivated
\&        1005    Transaction Type Not Allowed
\&        1006    Unsupported Processor
\&        1007    Invalid Request Message
\&        1008    Invalid Version
\&        1010    Payment Type Not Supported
\&        1011    Error Starting Transaction
\&        1012    Error Finishing Transaction
\&        1013    Error Checking Duplicate
\&        1014    No Records To Settle (in the current batch)
\&        1015    No Records To Process (in the current batch)
.Ve
.SS "\s-1AVS\s0 Response Codes"
.IX Subsection "AVS Response Codes"
.Vb 10
\&        X       Exact: Address and nine\-digit Zip match
\&        Y       Yes: Address and five\-digit Zip match
\&        A       Address: Address matches, Zip does not
\&        Z       5\-digit Zip: 5\-digit Zip matches, address doesn\*(Aqt
\&        W       Whole Zip: 9\-digit Zip matches, address doesn\*(Aqt
\&        N       No: Neither address nor Zip matches
\&        U       Unavailable: Address information not available
\&        G       Unavailable: Address information not available for international transaction
\&        R       Retry: System unavailable or time\-out
\&        E       Error: Transaction unintelligible for AVS or edit error found in the message that prevents AVS from being performed
\&        S       Not Supported: Issuer doesn\*(Aqt support AVS service
\&        B       * Street Match: Street addresses match for international transaction, but postal code doesn\*(Aqt
\&        C       * Street Address: Street addresses and postal code not verified for international transaction
\&        D       * Match: Street addresses and postal codes match for international transaction
\&        I       * Not Verified: Address Information not verified for International transaction
\&        M       * Match: Street addresses and postal codes match for international transaction
\&        P       * Postal Match: Postal codes match for international transaction, but street address doesn\*(Aqt
\&        0       ** No response sent
\&        5       Invalid AVS response
.Ve
.PP
* These values are Visa specific.
** These values are returned by the Payment Server and not the processor.
.SS "\s-1CVV\s0 Response Codes"
.IX Subsection "CVV Response Codes"
.Vb 6
\&        M       CVV2/CVC2/CID Match
\&        N       CVV2/CVC2/CID No Match
\&        P       Not Processed
\&        S       Issuer indicates that the CV data should be present on the card, but the merchant has indicated that the CV data is not present on the card.
\&        U       Unknown / Issuer has not certified for CV or issuer has not provided Visa/MasterCard with the CV encryption keys.
\&        X       Server Provider did not respond
.Ve
.SH "NOTE"
.IX Header "NOTE"
There is actually nothing in the package Vend::Payment::Merchantware. It
changes packages to Vend::Payment and places things there.
.SH "AUTHORS"
.IX Header "AUTHORS"
Josh Lavin <josh@perusion.com>
