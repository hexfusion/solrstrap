.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Vend::UserDB 3"
.TH Vend::UserDB 3 "2016-12-23" "perl v5.22.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
UserDB.pm \-\- Interchange User Database Functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
userdb \f(CW$function\fR, \f(CW%options\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Interchange user database saves information for users, including shipping,
billing, and preference information.  It allows the user to return to a
previous session without the requirement for a \*(L"cookie\*(R" or other persistent
session information.
.PP
It is object-oriented and called via the [userdb] usertag, which calls the
userdb subroutine.
.PP
It restores and manipulates the form values normally stored in the user session
values \*(-- the ones set in forms and read through the \f(CW\*(C`[value variable]\*(C'\fR tags.
A special function allows saving of shopping cart contents.
.PP
The preference, billing, and shipping information is keyed so that different
sets of information may be saved, providing and \*(L"address_book\*(R" function that
can save more than one shipping and/or billing address. The set to restore
is selected by the form values \f(CW\*(C`s_nickname\*(C'\fR, \f(CW\*(C`b_nickname\*(C'\fR, and \f(CW\*(C`p_nickname\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
User login:
.PP
.Vb 2
\&    $obj\->login();        # Form values are
\&                          # mv_username, mv_password
.Ve
.PP
Create account:
.PP
.Vb 2
\&    $obj\->new_account();  # Form values are
\&                          # mv_username, mv_password, mv_verify
.Ve
.PP
Change password:
.PP
.Vb 2
\&    $obj\->change_pass();  # Form values are
\&                          # mv_username, mv_password_old, mv_password, mv_verify(new)
.Ve
.PP
Get, set user information:
.PP
.Vb 3
\&    $obj\->get_values();
\&    $obj\->set_values();
\&    $obj\->clear_values();
.Ve
.PP
Save, restore filed user information:
.PP
.Vb 2
\&    $obj\->get_shipping();
\&    $obj\->set_shipping();
\&
\&    $obj\->get_billing();
\&    $obj\->set_billing();
\&
\&    $obj\->get_preferences();
\&    $obj\->set_preferences();
\&
\&    $obj\->get_cart();
\&    $obj\->set_cart();
.Ve
.SS "Shipping Address Book"
.IX Subsection "Shipping Address Book"
The shipping address book saves information relevant to shipping the
order. In its simplest form, this can be the only address book needed.
By default these form values are included:
.PP
.Vb 9
\&        s_nickname
\&        name
\&        address
\&        city
\&        state
\&        zip
\&        country
\&        phone_day
\&        mv_shipmode
.Ve
.PP
The values are saved with the \f(CW$obj\fR\->\fIset_shipping()\fR method and restored 
with \f(CW$obj\fR\->get_shipping. A list of the keys available is kept in the
form value \f(CW\*(C`address_book\*(C'\fR, suitable for iteration in an \s-1HTML\s0 select
box or in a set of links.
.SS "Accounts Book"
.IX Subsection "Accounts Book"
The accounts book saves information relevant to billing the
order. By default these form values are included:
.PP
.Vb 12
\&        b_nickname
\&        b_name
\&        b_address
\&        b_city
\&        b_state
\&        b_zip
\&        b_country
\&        b_phone
\&        mv_credit_card_type
\&        mv_credit_card_exp_month
\&        mv_credit_card_exp_year
\&        mv_credit_card_reference
.Ve
.PP
The values are saved with the \f(CW$obj\fR\->\fIset_billing()\fR method and restored 
with \f(CW$obj\fR\->get_billing. A list of the keys available is kept in the
form value \f(CW\*(C`accounts\*(C'\fR, suitable for iteration in an \s-1HTML\s0 select
box or in a set of links.
.SS "Preferences"
.IX Subsection "Preferences"
Preferences are miscellaneous session information. They include
by default the fields \f(CW\*(C`email\*(C'\fR, \f(CW\*(C`fax\*(C'\fR, \f(CW\*(C`phone_night\*(C'\fR,
and \f(CW\*(C`fax_order\*(C'\fR. The field \f(CW\*(C`p_nickname\*(C'\fR acts as a key to select
the preference set.
.SS "Locations"
.IX Subsection "Locations"
There are several database locations that have special purposes. These
fields are not saved as user values.
.IP "\s-1USERNAME			\s0	default: username" 4
.IX Item "USERNAME default: username"
The username or key field of the database table.
.IP "\s-1BILLING			\s0	default: accounts" 4
.IX Item "BILLING default: accounts"
Billing address hash field.
.IP "\s-1SHIPPING			\s0	default: address_book" 4
.IX Item "SHIPPING default: address_book"
Shipping address hash field.
.IP "\s-1PREFERENCES		\s0	default: preferences" 4
.IX Item "PREFERENCES default: preferences"
Miscellaneous information hash field.
.IP "\s-1FEEDBACK			\s0	default: feedback" 4
.IX Item "FEEDBACK default: feedback"
Customer feedback hash field.
.IP "\s-1PRICING			\s0	default: price_level" 4
.IX Item "PRICING default: price_level"
Customer pricing level marker.
.IP "\s-1CARTS				\s0	default: carts" 4
.IX Item "CARTS default: carts"
Saved carts hash field.
.IP "\s-1PASSWORD			\s0	default: password" 4
.IX Item "PASSWORD default: password"
Customer password info. If \f(CW\*(C`crypt\*(C'\fR is set, may be encrypted.
.IP "\s-1LAST				\s0	default: mod_time" 4
.IX Item "LAST default: mod_time"
Last login time
.IP "\s-1EXPIRATION		\s0	default: expiration" 4
.IX Item "EXPIRATION default: expiration"
Expiration of account.
.IP "\s-1OUTBOARD_KEY  	\s0	default: (none)" 4
.IX Item "OUTBOARD_KEY default: (none)"
Key information for linking to another table of address or other info.
.IP "\s-1GROUPS			\s0	default: groups" 4
.IX Item "GROUPS default: groups"
Groups they should be logged into.
.IP "\s-1SUPER				\s0	default: super" 4
.IX Item "SUPER default: super"
Whether they are a superuser (admin).
.IP "\s-1ACL				\s0	default: acl" 4
.IX Item "ACL default: acl"
.PD 0
.IP "\s-1FILE_ACL			\s0	default: file_acl" 4
.IX Item "FILE_ACL default: file_acl"
.IP "\s-1DB_ACL			\s0	default: db_acl" 4
.IX Item "DB_ACL default: db_acl"
.PD
Location of access control information.
.IP "\s-1CREATED_DATE_ISO	\s0	default: (none)" 4
.IX Item "CREATED_DATE_ISO default: (none)"
.PD 0
.IP "\s-1CREATED_DATE_UNIX	\s0	default: (none)" 4
.IX Item "CREATED_DATE_UNIX default: (none)"
.IP "\s-1UPDATED_DATE_ISO	\s0	default: (none)" 4
.IX Item "UPDATED_DATE_ISO default: (none)"
.IP "\s-1UPDATED_DATE_UNIX	\s0	default: (none)" 4
.IX Item "UPDATED_DATE_UNIX default: (none)"
.PD
Date fields.
.IP "\s-1MERGED_USER		\s0	default: (none)" 4
.IX Item "MERGED_USER default: (none)"
The user id of another account this was merged into. If present, and data (should
be a valid user id) is present in the field, the user will be logged as that username.
.IP "enclair_db" 4
.IX Item "enclair_db"
Using \fIset_enclair()\fR allows logging of enclair password to separate
database table. Designed to allow administration personnel to look
at passwords, without allowing access to web-connected systems. Or
perhaps more properly, to check prior MD5\-encrypted password values 
for repeat passwords.
.Sp
Designed to log to an insert-only handle on a table, with a database
structure such as:
.Sp
.Vb 5
\&  create table enclair (
\&    username varchar(32),
\&     password varchar(32),
\&     update_date timestamp
\&    )
.Ve
.Sp
Then a program on a secure behind-firewall no-select write-only
database can access the table, logged via request and username.
.Sp
Configured:
.Sp
.Vb 1
\&        UserDB   default  enclair_db   some_table
.Ve
.Sp
You can set the following, which have the defaults shown in the
setting. You can also insert \f(CW%M\fR, which is the \s-1MD5\s0 of the password, or
\&\f(CW%D\fR which is a datetime localtime value in the form YYYYmmddHHMMSS.
.Sp
.Vb 3
\&        #UserDB   default  enclair_key_field   username
\&        #UserDB   default  enclair_field       password
\&        #UserDB   default  enclair_query_template "INSERT INTO %t (%U,%P) values (%u,%p)"
.Ve
.Sp
String substitutions:
.Sp
.Vb 7
\&        %u  value of username
\&        %p  value of password
\&        %U  field of username
\&        %P  field of password
\&        %t  enclair table name
\&        %D  datetime value of form YYYYmmddHHMMSS
\&        %M  MD5 hashed value of password
.Ve
.SS "The [userdb ...] tag"
.IX Subsection "The [userdb ...] tag"
Interchange provides a \f(CW\*(C`[userdb ...]\*(C'\fR tag to access the UserDB functions.
.PP
.Vb 10
\& [userdb
\&        function=function_name
\&        username="username"
\&        assign_username=1
\&        username_mask=REGEX
\&        password="password"
\&        verify="password"
\&        oldpass="old password"
\&        crypt="1|0"
\&                bcrypt=1
\&                promote=1
\&                md5=1
\&                md5_salted=1
\&                sha1=1
\&                valref=user_record
\&                scratchref=user_record
\&        shipping="fields for shipping save"
\&        billing="fields for billing save"
\&        preferences="fields for preferences save"
\&        ignore_case="1|0"
\&        force_lower=1
\&        param1=value
\&        param2=value
\&        ...
\&        ]
.Ve
.PP
All parameters are optional except for the function. Normally, parameters 
are set in catalog.cfg with the \fIUserDB\fR directive.
.PP
It is normally called in an \f(CW\*(C`mv_click\*(C'\fR or \f(CW\*(C`mv_check\*(C'\fR setting, as in:
.PP
.Vb 5
\&    [set Login]
\&    mv_todo=return
\&    mv_nextpage=welcome
\&    [userdb function=login]
\&    [/set]
\&
\&    <FORM ACTION="[process\-target]" METHOD=POST>
\&    <INPUT TYPE=hidden NAME=mv_click VALUE=Login>
\&    Username <INPUT NAME=mv_username SIZE=10>
\&    Password <INPUT NAME=mv_password SIZE=10>
\&    </FORM>
.Ve
.PP
There are several global parameters that apply to any use of
the \f(CW\*(C`userdb\*(C'\fR functions. Most importantly, by default the database
table is set to be \fIuserdb\fR. If you must use another table name,
then you should include a \f(CW\*(C`database=table\*(C'\fR parameter with any
call to \f(CW\*(C`userdb\*(C'\fR. The global parameters (default in parens):
.PP
.Vb 10
\&    database     Sets user database table (userdb)
\&    show         Show the return value of certain functions
\&                 or the error message, if any (0)
\&    force_lower  Force possibly upper\-case database fields
\&                 to lower case session variable names (0)
\&    billing      Set the billing fields (see Accounts)
\&    shipping     Set the shipping fields (see Address Book)
\&    preferences  Set the preferences fields (see Preferences)
\&    bill_field   Set field name for accounts (accounts)
\&    addr_field   Set field name for address book (address_book)
\&    pref_field   Set field name for preferences (preferences)
\&    cart_field   Set field name for cart storage (carts)
\&    pass_field   Set field name for password (password)
\&    time_field   Set field for storing last login time (time)
\&    expire_field Set field for expiration date (expire_date)
\&    acl          Set field for simple access control storage (acl)
\&    file_acl     Set field for file access control storage (file_acl)
\&    db_acl       Set field for database access control storage (db_acl)
.Ve
.PP
By default the system \fIcrypt()\fR call will be used to compare the
password. This is minimal security, but at least the passwords in the user
database will not be human readable. For better security, in descending
order of security, use:
.PP
.Vb 4
\&        bcrypt    Bcrypt, most secure
\&        sha1      SHA1 digest, more secure than MD5
\&        md5       Not so easily stored in cracklib as md5 unsalted
\&        md5       Better security than crypt
.Ve
.PP
If you don't keep actual user information, don't have users creating
accounts and setting the passwords themselvs, and don't do Interchange
administration via the \f(CW\*(C`UserDB\*(C'\fR capability, then you may
wish to use the <UserDB> directive (described below) to set
encryption off by default:
.PP
.Vb 1
\&    UserDB   default   crypt   0
.Ve
.PP
That will set encryption off by default. You can still set encryption
on by passing \f(CW\*(C`crypt=1\*(C'\fR with any call to a \f(CW\*(C`new_account\*(C'\fR, \f(CW\*(C`change_pass\*(C'\fR,
or \f(CW\*(C`login\*(C'\fR call.
.PP
\&\s-1WARNING:\s0 Using unencrypted passwords is never recommended if you have users
setting their passwords. They will use the same passwords as other systems,
possibly compromising important information.
.SS "Setting defaults with the UserDB directive"
.IX Subsection "Setting defaults with the UserDB directive"
The \fIUserDB\fR directive provides a way to set defaults for
the user database. For example, if you always wanted to save
and recall the scratch variable \f(CW\*(C`tickets\*(C'\fR in the user database
instead of the form variable \f(CW\*(C`tickets\*(C'\fR, you could set:
.PP
.Vb 1
\&    UserDB   default   scratch  tickets
.Ve
.PP
That makes every call to \f(CW\*(C`[userdb function=login]\*(C'\fR be equivalent
to \f(CW\*(C`[userdb function=login scratch=tickets]\*(C'\fR.
.PP
If you wish to override that default for one call only, you can
use \f(CW\*(C`[userdb function=login scratch="passes"]\*(C'\fR.
.PP
If you wish to log failed access authorizations, set the \f(CW\*(C`UserDB\*(C'\fR
profile parameter \f(CW\*(C`log_failed\*(C'\fR true:
.PP
.Vb 1
\&    UserDB  default  log_failed 1
.Ve
.PP
To disable logging of failed access authorizations (the default), set
the \f(CW\*(C`UserDB\*(C'\fR profile parameter \f(CW\*(C`log_failed\*(C'\fR to 0:
.PP
.Vb 1
\&    UserDB  default  log_failed 0
.Ve
.PP
The \fIUserDB\fR directive uses the same key-value pair settings
as the \fILocale\fR and \fIRoute\fR directives, and you may have more
than one set of defaults. You can set them in a hash structure:
.PP
.Vb 3
\&    UserDB  case_crypt  scratch     tickets
\&    UserDB  case_crypt  bcrypt      1
\&    UserDB  case_crypt  ignore_case 0
\&
\&    UserDB  default     scratch     tickets
\&    UserDB  default     sha1        1
\&    UserDB  default     ignore_case 1
.Ve
.PP
The last one to be set becomes the default.
.PP
The option \f(CW\*(C`profile\*(C'\fR selects the set to use. So if you wanted
usernames and passwords to be case sensitive with bcrypt encryption,
you could pass this call:
.PP
.Vb 1
\&    [userdb function=new_account profile=case_crypt]
.Ve
.PP
The username and password will be stored as typed in, and the
password will be encrypted in the database.
.SS "User Database functions"
.IX Subsection "User Database functions"
The user database features are implemented as a series of functions
attached to the \f(CW\*(C`userdb\*(C'\fR tag. The functions are:
.IP "login" 4
.IX Item "login"
Log in to Interchange. By default, the username is contained in the
form variable \f(CW\*(C`mv_username\*(C'\fR and the password in \f(CW\*(C`mv_password\*(C'\fR.
If the login is successful, the session value \f(CW\*(C`username\*(C'\fR
(\f(CW\*(C`[data session username]\*(C'\fR) will be set to the user name.
.Sp
This will recall the values of all non-special fields in the user
database and place them in their corresponding user form variables.
.IP "logout" 4
.IX Item "logout"
Log out of Interchange. No additional parameters are needed.
.IP "new_account" 4
.IX Item "new_account"
Create a new account. It requires the \f(CW\*(C`username\*(C'\fR, \f(CW\*(C`password\*(C'\fR, and
\&\f(CW\*(C`verify\*(C'\fR parameters, which are by default contained in the form
variables \f(CW\*(C`mv_username\*(C'\fR, \f(CW\*(C`mv_password\*(C'\fR, \f(CW\*(C`mv_verify\*(C'\fR respectively.
.Sp
If you set the \f(CW\*(C`assign_username\*(C'\fR parameter, then UserDB will assign
a sequential username. The \f(CW\*(C`counter\*(C'\fR parameter can be used to set
the filename (must be absolute), or you can accept the default of
CATALOG_DIR/etc/username.counter. The first username will be \*(L"U0001\*(R"
if the counter doesn't exist already.
.Sp
The \f(CW\*(C`ignore_case\*(C'\fR parameter forces the username and password to
lower case in the database, in effect rendering the username and
password case-insensitive.
.Sp
If you set \f(CW\*(C`username_mask\*(C'\fR to a valid Perl regular expression (without
the surrounding / /) then any username containing a matching string will
not be allowed for use. For example, to screen out order numbers from
being used by a random user:
.Sp
.Vb 3
\&    [userdb function=new_account
\&            username_mask="^[A\-Z]*[0\-9]"
\&            ]
.Ve
.Sp
The \fICookieLogin\fR directive (catalog.cfg) allows users to save
their username/password in a cookie. Expiration time is set by
\&\fISaveExpire\fR, renewed every time they log in. To cause the cookie to
be generated originally, the form variable \f(CW\*(C`mv_cookie_password\*(C'\fR or
\&\f(CW\*(C`mv_cookie_username\*(C'\fR must be set in the login form. The former causes
both username and password to be saved, the latter just the username.
.Sp
If you want to automatically create an account for every order,
you can do in the \fIOrderReport\fR file:
.Sp
.Vb 6
\&    [userdb function=new_account
\&            username="[value mv_order_number]"
\&            password="[value zip]"
\&            verify="[value zip]"
\&            database="orders"
\&            ]
.Ve
.Sp
This would be coupled with a login form that asked for order number and
zip code; thereupon allowing you to display the contents of a transaction
database with (presumably updated) order status information or a shipping
company tracking number.
.IP "change_pass" 4
.IX Item "change_pass"
Change the password on the currently logged-in account. It requires
the \f(CW\*(C`username\*(C'\fR, \f(CW\*(C`password\*(C'\fR, \f(CW\*(C`verify\*(C'\fR, and \f(CW\*(C`oldpass\*(C'\fR parameters,
which are by default contained in the form variables \f(CW\*(C`mv_username\*(C'\fR,
\&\f(CW\*(C`mv_password\*(C'\fR, \f(CW\*(C`mv_verify\*(C'\fR, \f(CW\*(C`mv_password_old\*(C'\fR respectively.
.IP "set_shipping" 4
.IX Item "set_shipping"
Active parameters: nickname, shipping, ship_field
.Sp
Place an entry in the shipping Address book. Example:
.Sp
.Vb 1
\&    [userdb function=set_shipping nickname=Dad]
.Ve
.Sp
See \fIAddress Book\fR below.
.IP "get_shipping" 4
.IX Item "get_shipping"
Active parameters: nickname, shipping, ship_field
.Sp
Recall an entry from the shipping Address book. Example:
.Sp
.Vb 1
\&    [userdb function=get_shipping nickname=Dad]
.Ve
.Sp
See \fIAddress Book\fR below.
.IP "get_shipping_names" 4
.IX Item "get_shipping_names"
Active parameters: ship_field
.Sp
Gets the names of shipping address book entries and places
them in the variable \f(CW\*(C`address_book\*(C'\fR. By default, it does not return
the values; if you wish them to be returned you can set
the parameter \f(CW\*(C`show\*(C'\fR to 1, as in:
.Sp
.Vb 4
\&    [set name=shipping_nicknames
\&         interpolate=1]
\&      [userdb function=get_shipping_names show=1]
\&    [/set]
.Ve
.IP "set_billing" 4
.IX Item "set_billing"
Active parameters: nickname, billing, bill_field
.Sp
Place an entry in the billing accounts book. Example:
.Sp
.Vb 1
\&    [userdb function=set_billing nickname=discover]
.Ve
.Sp
See \fIAccounts Book\fR below.
.IP "get_billing" 4
.IX Item "get_billing"
Active parameters: nickname, billing, bill_field
.Sp
Recall an entry from the billing accounts book. Example:
.Sp
.Vb 1
\&    [userdb function=get_billing nickname=visa]
.Ve
.Sp
See \fIAccounts Book\fR below.
.IP "save" 4
.IX Item "save"
Saves all non-special form values that have columns in the user database.
.IP "load" 4
.IX Item "load"
Performs the transfer of user values to the values space, scratch space, and
constant space. Performed automatically upon login.
.Sp
If you pass the \f(CW\*(C`valref\*(C'\fR option, that will be used instead of \f(CW$Values\fR for
the values space. It can either be a real hash reference, or a scalar that
will be a key directly in \f(CW$Vend::Session\fR. If it contains a colon (\f(CW\*(C`:\*(C'\fR), it
will be a subreference in \f(CW$Vend::Session\fR. For example:
.Sp
.Vb 1
\&        [userdb function=load valref=\`$Session\->{user_record} ||= {}\`]
.Ve
.Sp
Will store the values in \f(CW\*(C`$Vend::Session\-\*(C'\fR{user_record}>, clearing it first.
The below accomplishes the same thing:
.Sp
.Vb 1
\&        [userdb function=load valref=user_record]
.Ve
.Sp
If you want to place it a couple of levels down, do:
.Sp
.Vb 1
\&        [userdb function=load valref=\`$Session\->{values_repository}{userdb} ||= {}\`]
.Ve
.Sp
or
.Sp
.Vb 1
\&        [userdb function=load valref="values_repository:userdb"]
.Ve
.Sp
To clear the record instead of add to the existing values, add an
asterisk at the end:
.Sp
.Vb 1
\&        [userdb function=load valref="values_repository:userdb*"]
.Ve
.Sp
Which is equivalent to:
.Sp
.Vb 1
\&        [userdb function=load valref=\`$Session\->{values_repository}{userdb} = {}\`]
.Ve
.Sp
The \f(CW\*(C`scratchref\*(C'\fR option is the same as \f(CW\*(C`valref\*(C'\fR, but for the scratch values
passed with \f(CW\*(C`UserDB scratch\*(C'\fR.
.IP "set_cart" 4
.IX Item "set_cart"
Save the contents of a shopping cart.
.Sp
.Vb 1
\&    [userdb function=set_cart nickname=christmas]
.Ve
.Sp
See \fICarts\fR below.
.IP "get_cart" 4
.IX Item "get_cart"
Active parameters: nickname, carts_field, target
.Sp
Recall a saved shopping cart.
.Sp
.Vb 1
\&    [userdb function=get_cart nickname=mom_birthday]
.Ve
.Sp
Setting \f(CW\*(C`target\*(C'\fR saves to a different shopping cart than the
default main cart. The \f(CW\*(C`carts_field\*(C'\fR controls the database
field used for storage.
.IP "set_acl" 4
.IX Item "set_acl"
Active parameters: location, acl_field, delete
.Sp
Set a simple acl. Example:
.Sp
.Vb 1
\&    [userdb function=set_acl location=cartcfg/editcart]
.Ve
.Sp
This allows the current user to access the page \*(L"cartcfg/editcart\*(R" if 
it is access-protected.
.Sp
To delete access, do:
.Sp
.Vb 1
\&    [userdb function=set_acl location=cartcfg/editcart delete=1]
.Ve
.Sp
To display the setting at the same time as setting use the
\&\f(CW\*(C`show\*(C'\fR attribute:
.Sp
.Vb 1
\&    [userdb function=set_acl location=cartcf/editcart show=1]
.Ve
.IP "check_acl" 4
.IX Item "check_acl"
Active parameters: location, acl_field
.Sp
Checks the simple access control listing for a location, returning
1 if allowed and the empty string if not allowed.
.Sp
.Vb 7
\&    [if type=explicit
\&        compare="[userdb
\&                    function=check_acl
\&                    location=cartcfg/editcart]"
\&    ]
\&    [page cartcfg/editcart]Edit your cart configuration[/page]
\&    [/if]
.Ve
.IP "set_file_acl, set_db_acl" 4
.IX Item "set_file_acl, set_db_acl"
Active parameters: location, mode, db_acl_field, file_acl_field, delete
.Sp
Sets a complex access control value. Takes the form:
.Sp
.Vb 3
\&    [userdb function=set_file_acl
\&            mode=rw
\&            location=products/inventory.txt]
.Ve
.Sp
where mode is any value you wish to check for with check_file_acl. As
with the simple \s-1ACL,\s0 you can use delete=1 to delete the location entirely.
.IP "check_file_acl, check_db_acl" 4
.IX Item "check_file_acl, check_db_acl"
Active parameters: location, mode, db_acl_field, file_acl_field
.Sp
Checks a complex access control value and returns a true/false (1/0)
value. Takes the form:
.Sp
.Vb 3
\&    [userdb function=check_db_acl
\&            mode=w
\&            location=inventory]
.Ve
.Sp
where mode is any value you wish to check for with check_file_acl. It
will return true if the mode string is contained within the entry
for that location. Example:
.Sp
.Vb 12
\&    [if type=explicit
\&        compare="[userdb
\&                    function=check_db_acl
\&                    mode=w
\&                    location=inventory]"
\&    ]
\&    [userdb function=set_acl location=cartcfg/edit_inventory]
\&    [page cartcfg/edit_inventory]You may edit the inventory database[/page]
\&    [else]
\&    [userdb function=set_acl location=cartcfg/edit_inventory delete=1]
\&    Sorry, you can\*(Aqt edit inventory.
\&    [/if]
.Ve
